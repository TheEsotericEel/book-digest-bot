"""BookDigest Bot - AI-powered book summaries on Telegram"""
import logging
import requests
from datetime import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, LabeledPrice
from telegram.ext import (
    Application, CommandHandler, MessageHandler, 
    CallbackQueryHandler, ContextTypes, PreCheckoutQueryHandler, filters
)

import config
import database as db

# Enable logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.FileHandler('bot.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# === HELPER FUNCTIONS ===

def search_google_books(query: str, max_results: int = 5) -> list:
    """Search for books using Google Books API"""
    try:
        url = "https://www.googleapis.com/books/v1/volumes"
        params = {
            'q': query,
            'maxResults': max_results,
            'printType': 'books',
            'langRestrict': 'en'
        }
        
        if config.GOOGLE_BOOKS_API_KEY:
            params['key'] = config.GOOGLE_BOOKS_API_KEY
        
        response = requests.get(url, params=params, timeout=10)
        response.raise_for_status()
        
        data = response.json()
        
        if 'items' not in data:
            return []
        
        books = []
        for item in data['items']:
            vol_info = item.get('volumeInfo', {})
            books.append({
                'title': vol_info.get('title', 'Unknown'),
                'authors': vol_info.get('authors', []),
                'description': vol_info.get('description', ''),
                'isbn': next((id['identifier'] for id in vol_info.get('industryIdentifiers', []) 
                             if id['type'] in ['ISBN_13', 'ISBN_10']), None),
                'pageCount': vol_info.get('pageCount', 0),
                'categories': vol_info.get('categories', [])
            })
        
        return books
    
    except Exception as e:
        logger.error(f"Google Books API error: {e}")
        return []

def generate_ai_summary(book_title: str, author: str, description: str = "") -> str:
    """Generate book summary using AI or description"""
    # For MVP, we'll use the book description as base and format it nicely
    # In production, you'd call an LLM API here (OpenAI, Anthropic, etc.)
    
    if not description or len(description) < config.MIN_SUMMARY_LENGTH:
        # Fallback summary template
        return f"""üìö **{book_title}**
by {author}

This book is currently being summarized by our AI system. 

**Key Topics:**
- Main themes and concepts
- Important takeaways
- Practical applications

**Who should read this:**
Anyone interested in learning more about the subject matter.

*Note: Full AI summary coming soon. Check back later for a detailed breakdown.*
"""
    
    # Format the description nicely
    summary = f"""üìö **{book_title}**
by {author}

**Summary:**
{description[:config.MAX_SUMMARY_LENGTH]}

**Reading Time:** ~{len(description) // 1000} minutes

---
*Generated by BookDigest AI*
"""
    
    return summary

# === COMMAND HANDLERS ===

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Start command - welcome new users"""
    user = update.effective_user
    db_user = db.get_or_create_user(
        telegram_id=user.id,
        username=user.username,
        first_name=user.first_name
    )
    
    is_new = db_user['credits'] == config.FREE_SIGNUP_CREDITS
    
    welcome_msg = f"""üëã Welcome to **BookDigest Bot**, {user.first_name}!

Get AI-powered summaries of any book in seconds. üìñ

{"üéÅ **You've got 2 FREE summaries to start!**" if is_new else ""}

**Quick Commands:**
/search [book title] - Find a book
/summary [book title] - Get instant summary (costs 1 credit)
/library - Your saved summaries
/credits - Check your balance ({db_user['credits']} credits)
/buy - Purchase more credits

**How it works:**
1. Search for any book with /search
2. Request a summary (uses 1 credit)
3. Get a comprehensive AI summary instantly

**Pricing:**
üíé 5 summaries = 250 Stars (~$5)
üåü Pro Plan = 500 Stars/month (15 summaries + daily recommendations)

Much cheaper than Blinkist or getAbstract!

Try it now: /search Atomic Habits
"""
    
    await update.message.reply_text(welcome_msg, parse_mode='Markdown')

async def search_books(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Search for books"""
    user_id = update.effective_user.id
    
    # Get search query
    if not context.args:
        await update.message.reply_text(
            "üìö **Usage:** /search [book title]\n\n"
            "Example: `/search The 4-Hour Workweek`",
            parse_mode='Markdown'
        )
        return
    
    query = ' '.join(context.args)
    
    # Show searching message
    status_msg = await update.message.reply_text(f"üîç Searching for *{query}*...", parse_mode='Markdown')
    
    # Search Google Books
    books = search_google_books(query)
    
    if not books:
        await status_msg.edit_text(
            f"‚ùå No books found for '{query}'.\n\n"
            "Try a different search term or check the spelling."
        )
        return
    
    # Format results
    result_msg = f"üìö **Search Results for:** {query}\n\n"
    
    for i, book in enumerate(books[:5], 1):
        authors = ', '.join(book['authors'][:2]) if book['authors'] else 'Unknown Author'
        pages = f"{book['pageCount']} pages" if book['pageCount'] else ""
        categories = f"({', '.join(book['categories'][:2])})" if book['categories'] else ""
        
        result_msg += f"{i}. **{book['title']}**\n"
        result_msg += f"   by {authors}\n"
        if pages:
            result_msg += f"   {pages} {categories}\n"
        result_msg += f"   `/summary {book['title'][:30]}`\n\n"
    
    result_msg += "\nüí° Tip: Use /summary to get a comprehensive AI summary!"
    
    await status_msg.edit_text(result_msg, parse_mode='Markdown')

async def get_summary(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Get book summary (costs 1 credit)"""
    user_id = update.effective_user.id
    
    # Get book title from args
    if not context.args:
        await update.message.reply_text(
            "üìö **Usage:** /summary [book title]\n\n"
            "Example: `/summary Atomic Habits`\n\n"
            "First, try searching: /search [book title]",
            parse_mode='Markdown'
        )
        return
    
    book_title = ' '.join(context.args)
    
    # Check if user has credits
    credits = db.get_user_credits(user_id)
    if credits < 1:
        keyboard = [[InlineKeyboardButton("üíé Buy Credits", callback_data="buy_credits")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            "‚ùå **Insufficient credits!**\n\n"
            f"You have {credits} credits.\n"
            "You need 1 credit to generate a summary.\n\n"
            "üí° Get more credits with /buy",
            parse_mode='Markdown',
            reply_markup=reply_markup
        )
        return
    
    # Show processing message
    status_msg = await update.message.reply_text(
        f"üìñ Generating summary for *{book_title}*...\n\n"
        "This may take a few seconds.",
        parse_mode='Markdown'
    )
    
    # Check if summary exists in cache
    cached_summary = db.get_or_create_summary(book_title)
    
    if cached_summary:
        summary_text = cached_summary['summary_text']
        summary_id = cached_summary['id']
    else:
        # Search for the book first
        books = search_google_books(book_title, max_results=1)
        
        if not books:
            await status_msg.edit_text(
                f"‚ùå Book not found: '{book_title}'\n\n"
                "Try using /search to find the exact title."
            )
            return
        
        book = books[0]
        author = ', '.join(book['authors']) if book['authors'] else 'Unknown'
        
        # Generate summary
        summary_text = generate_ai_summary(
            book['title'],
            author,
            book['description']
        )
        
        # Save to database
        summary_id = db.save_summary(
            book_title=book['title'],
            author=author,
            summary_text=summary_text,
            isbn=book['isbn']
        )
    
    # Spend credit
    if db.spend_credit(user_id):
        # Log access
        db.log_user_summary_access(user_id, summary_id)
        
        # Send summary
        remaining = db.get_user_credits(user_id)
        await status_msg.edit_text(
            f"{summary_text}\n\n"
            f"üí≥ Credits remaining: {remaining}\n"
            f"üìö View your library: /library",
            parse_mode='Markdown'
        )
    else:
        await status_msg.edit_text(
            "‚ùå Error spending credit. Please try again or contact support."
        )

async def library(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show user's summary library"""
    user_id = update.effective_user.id
    
    summaries = db.get_user_library(user_id, limit=10)
    
    if not summaries:
        await update.message.reply_text(
            "üìö **Your Library is Empty**\n\n"
            "You haven't accessed any summaries yet.\n\n"
            "Try: /search [book title]",
            parse_mode='Markdown'
        )
        return
    
    msg = "üìö **Your Summary Library**\n\n"
    
    for i, summary in enumerate(summaries, 1):
        accessed = datetime.fromisoformat(summary['accessed_at']).strftime('%b %d')
        msg += f"{i}. **{summary['book_title']}**\n"
        if summary['author']:
            msg += f"   by {summary['author']}\n"
        msg += f"   Accessed: {accessed}\n"
        msg += f"   `/summary {summary['book_title'][:30]}`\n\n"
    
    msg += "\nüí° Tip: Request a summary again to view it (no credit charged for re-reads!)"
    
    await update.message.reply_text(msg, parse_mode='Markdown')

async def check_credits(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Check credit balance"""
    user_id = update.effective_user.id
    user = db.get_or_create_user(user_id)
    
    credits = user['credits']
    tier = user['tier']
    
    msg = f"üí≥ **Your Credits: {credits}**\n\n"
    
    if tier == 'pro':
        expires = user.get('pro_expires_at', '')
        if expires:
            expires_date = datetime.fromisoformat(expires).strftime('%b %d, %Y')
            msg += f"üåü Pro Member (expires {expires_date})\n\n"
    else:
        msg += "üÜì Free Tier\n\n"
    
    msg += "**Credit Info:**\n"
    msg += "‚Ä¢ Each summary costs 1 credit\n"
    msg += "‚Ä¢ Free users get 1 credit/week\n"
    msg += "‚Ä¢ Pro users get 15 credits/month\n\n"
    
    if credits < 3:
        msg += "‚ö†Ô∏è Running low on credits!\n"
        msg += "üí° Use /buy to get more"
    
    await update.message.reply_text(msg, parse_mode='Markdown')

async def buy_credits(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show purchase options"""
    keyboard = [
        [InlineKeyboardButton("üíé 5 Summaries (250 Stars)", callback_data="buy_pack_5")],
        [InlineKeyboardButton("üåü Pro Plan (500 Stars/month)", callback_data="buy_pro")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    msg = """üíé **Purchase Credits**

**Credit Pack:**
‚Ä¢ 5 summaries = 250 Stars (~$5)
‚Ä¢ That's $1 per summary!

**Pro Plan:**
‚Ä¢ 15 summaries/month = 500 Stars (~$10)
‚Ä¢ Daily book recommendations
‚Ä¢ That's $0.66 per summary!

**Compare to competitors:**
‚Ä¢ Blinkist: $12.99/month
‚Ä¢ getAbstract: $29/month
‚Ä¢ Shortform: $24/month

Much cheaper, right? üòâ

Select an option below:
"""
    
    await update.message.reply_text(msg, parse_mode='Markdown', reply_markup=reply_markup)

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle button callbacks"""
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    
    if query.data == "buy_credits":
        # Same as /buy command
        await buy_credits(update, context)
    
    elif query.data == "buy_pack_5":
        # Create invoice for 5 credit pack
        if config.ENABLE_PAYMENTS:
            await query.message.reply_text(
                "üíé **Purchase 5 Summaries**\n\n"
                "Payment processing coming soon!\n"
                "For now, contact @yourusername to manually purchase credits.",
                parse_mode='Markdown'
            )
            # TODO: Implement Telegram Stars payment
            # await context.bot.send_invoice(...)
        else:
            # Manual credit addition for testing
            db.add_credits(user_id, 5, "test_pack")
            await query.message.reply_text(
                "‚úÖ **5 credits added!** (test mode)\n\n"
                "Check your balance: /credits",
                parse_mode='Markdown'
            )
    
    elif query.data == "buy_pro":
        if config.ENABLE_PAYMENTS:
            await query.message.reply_text(
                "üåü **Pro Plan**\n\n"
                "Payment processing coming soon!\n"
                "For now, contact @yourusername to upgrade.",
                parse_mode='Markdown'
            )
        else:
            # Manual upgrade for testing
            db.upgrade_to_pro(user_id, duration_days=30)
            await query.message.reply_text(
                "‚úÖ **Upgraded to Pro!** (test mode)\n\n"
                "‚Ä¢ 15 credits added\n"
                "‚Ä¢ Pro expires in 30 days\n\n"
                "Check: /credits",
                parse_mode='Markdown'
            )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show help message"""
    msg = """üìñ **BookDigest Bot - Help**

**Commands:**
/start - Welcome & introduction
/search [book] - Find books
/summary [book] - Get AI summary (1 credit)
/library - Your saved summaries
/credits - Check balance
/buy - Purchase credits
/stats - Bot statistics (admin)
/help - This message

**How It Works:**
1. Search for books: `/search Atomic Habits`
2. Request summary: `/summary Atomic Habits`
3. Read comprehensive AI summary
4. Save to your library

**Credits:**
‚Ä¢ Free: 2 credits on signup, 1/week after
‚Ä¢ Pack: 5 summaries for 250 Stars (~$5)
‚Ä¢ Pro: 15/month for 500 Stars (~$10)

**Support:**
Questions? Bugs? Contact @yourusername

**Why BookDigest?**
‚úÖ Cheaper than Blinkist ($12.99/mo)
‚úÖ Instant summaries on Telegram
‚úÖ No app download needed
‚úÖ AI-powered & constantly improving

Happy reading! üìö
"""
    
    await update.message.reply_text(msg, parse_mode='Markdown')

async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show bot statistics"""
    stats = db.get_stats()
    
    msg = f"""üìä **BookDigest Bot Stats**

**Users:**
‚Ä¢ Total: {stats['total_users']}
‚Ä¢ Free: {stats['free_users']}
‚Ä¢ Pro: {stats['pro_users']}

**Content:**
‚Ä¢ Summaries cached: {stats['total_summaries']}
‚Ä¢ Total accesses: {stats['total_accesses']}

**Revenue:**
‚Ä¢ Total Stars: {stats['total_revenue_stars']}
‚Ä¢ Estimated USD: ${stats['total_revenue_usd']:.2f}

**Conversion Rate:**
{(stats['pro_users'] / stats['total_users'] * 100) if stats['total_users'] > 0 else 0:.1f}% of users are Pro

---
Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
    
    await update.message.reply_text(msg, parse_mode='Markdown')

# === MAIN ===

def main():
    """Start the bot"""
    if not config.TELEGRAM_BOT_TOKEN:
        print("‚ùå Error: TELEGRAM_BOT_TOKEN not set!")
        print("Set it with: export TELEGRAM_BOT_TOKEN='your_token_here'")
        return
    
    # Initialize database
    db.init_db()
    
    # Create application
    application = Application.builder().token(config.TELEGRAM_BOT_TOKEN).build()
    
    # Add command handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("search", search_books))
    application.add_handler(CommandHandler("summary", get_summary))
    application.add_handler(CommandHandler("library", library))
    application.add_handler(CommandHandler("credits", check_credits))
    application.add_handler(CommandHandler("buy", buy_credits))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("stats", stats_command))
    
    # Add callback query handler
    application.add_handler(CallbackQueryHandler(button_callback))
    
    # Start bot
    logger.info("üöÄ BookDigest Bot starting...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()
